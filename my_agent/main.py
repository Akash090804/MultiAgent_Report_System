import asyncio
import os
from dotenv import load_dotenv
from google.genai import types
from google.adk.agents import SequentialAgent
from google.adk.sessions import InMemorySessionService
from google.adk.runners import Runner
from agent import rootagent
from pdf_generator_simple import convert_markdown_to_pdf, extract_title_from_markdown
from datetime import datetime
import re

# Load environment variables FIRST
load_dotenv()

# Verify API key is loaded
api_key = os.getenv("GOOGLE_API_KEY")
if not api_key:
    raise ValueError("GOOGLE_API_KEY not found in .env file!")

print(f"API Key loaded: {api_key[:20]}...")
APP_NAME = "my_agent"  
USER_ID = "user_1"

async def run_pipeline(topic: str,generate_pdf: bool, author_name:str= None , description: str = None):
    """
    Runs the multi-agent pipeline sequentially:
    Planner â†’ Researcher â†’ Writer â†’ Formatter
    """
    print("\n" + "="*70)
    print(" MULTI-AGENT REPORT GENERATOR")
    print("="*70)
    
    pipeline = rootagent

    # Create session service and runner
    session_service = InMemorySessionService()
    
    # Create runner with API key explicitly
    runner = Runner(
        app_name=APP_NAME,
        agent=pipeline,
        session_service=session_service,
    )

    # Generate unique session ID
    import uuid
    session_id = f"session_{uuid.uuid4().hex[:8]}"

    # Create session
    await session_service.create_session(
        app_name=APP_NAME, 
        user_id=USER_ID, 
        session_id=session_id
    )

    # Create message with proper format
    full_prompt = topic
    if description:
        full_prompt = f"Topic:{topic}\nDescription:{description}"
    else:
        full_prompt = f"Topic:{topic}"
        
            
    user_message = types.Content(
        role='user',
        parts=[types.Part(text=full_prompt)]
    )

    print(f"\n Topic: {topic}")
    print("\n Processing Pipeline Stages:\n")

    # Execute pipeline with top-level retry to handle overloaded model (503) errors
    from google.genai import errors as genai_errors

    response_events = []
    current_agent = None

    max_attempts = 3
    for attempt in range(1, max_attempts + 1):
        try:
            async for event in runner.run_async(
                session_id=session_id,
                user_id=USER_ID,
                new_message=user_message,
            ):
                response_events.append(event)

                # Track agent progress
                if hasattr(event, 'author'):
                    if event.author != current_agent:
                        current_agent = event.author
                        agent_emoji = {
                            'planner_agent': 'ðŸ“‹',
                            'research_agent': 'ðŸ”¬',
                            'writer_agent': 'âœï¸',
                            'formatter_agent': 'âœ¨'
                        }.get(current_agent, 'ðŸ¤–')
                        print(f"{agent_emoji} {current_agent.replace('_', ' ').title()} is working...")

            # If we complete the async for without exceptions, break out of retry loop
            break

        except genai_errors.ServerError as e:
            # ServerError indicates transient server-side issues (e.g. 503 overloaded)
            print(f"Model request failed (attempt {attempt}/{max_attempts}): {e}")
            if attempt == max_attempts:
                # re-raise so outer try/except in main() can show traceback
                raise
            backoff = 2 ** attempt
            print(f"Retrying in {backoff} seconds...")
            await asyncio.sleep(backoff)
        except Exception:
            # Non-transient error â€” re-raise immediately
            raise

    # Retrieve final output (pass required keyword-only args)
    session = await session_service.get_session(
        session_id=session_id,
        app_name=APP_NAME,
        user_id=USER_ID,
    )
    state = session.state

    # Get final markdown
    final_md = state.get("final_markdown", "")
    if not final_md:
        final_md = state.get("draft", "") or state.get("research", "") or state.get("outline", "")
    
    if not final_md:
        print("NO Output generated by agents.")
        return None    
    
    os.makedirs("outputs",exist_ok=True)
    # Build safe filenames from the generated content title (not raw topic)
    def sanitize_filename(name: str, max_len: int = 120) -> str:
        # Normalize whitespace and remove control/newline characters
        name = name.strip()
        name = name.replace('\n', ' ').replace('\r', ' ')
        # Replace any sequence of non-alphanumeric characters with underscore
        name = re.sub(r'[^A-Za-z0-9._-]+', '_', name)
        # Trim repeated underscores
        name = re.sub(r'_+', '_', name)
        # Trim to max length
        if len(name) > max_len:
            name = name[:max_len]
        # Ensure it doesn't start or end with underscore or dot
        name = name.strip('_.')
        if not name:
            name = 'report'
        return name

    report_title = extract_title_from_markdown(final_md)
    safe_base = sanitize_filename(report_title)

    md_output_path = os.path.join('outputs', f"final_report_{safe_base}.md")
    with open(md_output_path, "w", encoding="utf-8") as f:
        f.write(final_md)


    print("\n" + "="*70)
    print(f" Markdown Report Generated Successfully!")
    print(f" Saved to: {md_output_path}")
    print(f" Total length: {len(final_md)} characters")
    print("="*70)
     
    # Convert to pdf 
    pdf_output_path = None
    if generate_pdf:
        print("\n Generating the pdf version...")
        try:
            report_title = extract_title_from_markdown(final_md)
            metadata = {
                "title": report_title,
                "author": author_name or "AI Report Generator",
                "date": datetime.now().strftime("%B %d, %Y")
                
            }
            pdf_output_path = os.path.join('outputs', f"final_report_{safe_base}.pdf")
            convert_markdown_to_pdf(
                markdown_content=final_md,
                output_path=pdf_output_path,
                metadata=metadata
            )
            
            if os.path.exists(pdf_output_path):
                pdf_size = os.path.getsize(pdf_output_path)
                pdf_size_mb = pdf_size/(1024*1024)
                print(f" âœ… PDF Report Generated Successfully! ({pdf_size_mb:.2f} MB)")
            else:
                print(f" âš ï¸  PDF generation function completed but file not found at: {pdf_output_path}")
                pdf_output_path = None
        
        except Exception as e:
            print(f" âŒ Error generating PDF: {e}")
            import traceback
            traceback.print_exc()
            print("Markdown to PDF conversion failed.")
            pdf_output_path = None
    else:
        print(" â­ï¸  PDF generation skipped (user chose not to generate).")
                
    print("\n" + "="*70)    
    # Show preview
    print("\n PREVIEW (First 800 characters):")
    print("-"*70)
    print(final_md[:800])
    if len(final_md) > 800:
        print("\n... [truncated]")
    print("-"*70)
    
    print("Generated Files:")
    print(f" - Markdown: {md_output_path}")
    if pdf_output_path and os.path.exists(pdf_output_path):
        print(f" - PDF: {pdf_output_path} ({pdf_size_mb:.2f} MB)")
    
    print()
            
    return {
        "markdown_path": md_output_path,
        "pdf_path": pdf_output_path
    }
    

def main():
    """Main entry point"""
    print("\n" + "="*70)
    print(" AI REPORT GENERATOR - Multi-Agent System")
    print("="*70)
    print("\nThis system uses 4 specialized AI agents:")
    print("   Planner    - Creates document outline")
    print("   Researcher - Gathers detailed information")
    print("    Writer     - Composes full report")
    print("   Formatter  - Polishes and formats")
    print("="*70)
    
    topic = input("\n Enter your project topic: ").strip()
    
    if not topic:
        print(" Error: Topic cannot be empty!")
        return
    print("\n Add description to help agents understand your requirements better.")
    description = input("Enter description (optional):").strip()
    
    if description:
        topic = f"{topic}\n\nDescription: {description}"
        print(f"\n Updated Topic with Description:\n{topic}")
    
    author_name = input(" Enter author name (optional):").strip()
    if not author_name:
        author_name = None
        
    pdf_choice = input(" Want to generate PDF ? (Y/n):").strip().lower()
    generate_pdf = pdf_choice != "n"
      
    print(f"\n Processing... This may take 1-2 minutes...")
    
    try:
        result = asyncio.run(run_pipeline(topic,generate_pdf,author_name,description))
        
        if result:
            print("\n Report generation completed successfully!")
            print("\nðŸ’¡ Tips:")
            print("   â€¢ Open the PDF with any PDF reader")
            print("   â€¢ Markdown file can be edited if needed")
            print("   â€¢ Both files are in the 'outputs' folder")
            print()
            
    except Exception as e:
        print(f"\n Error occurred: {e}")
        import traceback
        traceback.print_exc()
        print("\n Troubleshooting Tips:")
        print("Ensure stable internet connectivity.")
        print("\n Important Tip: Check your .env file and API key configuration.")
        print("Try again in few moments if quota exceeded.")
        

if __name__ == "__main__":
    main()